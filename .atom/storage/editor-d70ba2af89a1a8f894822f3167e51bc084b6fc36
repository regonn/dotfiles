{"mode":"editor","version":1,"windowDimensions":{"x":0,"y":22,"width":1214,"height":798},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/regonn","buffers":[{"text":"#include <iostream>\n#include <string.h>\n#include <fstream>\n#include <math.h>\n#include <cstdlib>\n#include <time.h>\nusing namespace std;\n#define PI 3.1415926535\n#define dt 0.01//ルンゲクッタ法の時間幅\n#define TIME 50\n#define NEURON_NUMBER 90//ニューロン数\n#define D_I_OUTPUT_VALUE 0.5\n#define TASK_STEP ((22*1)-1)\n#define WEIGHT_MAX 1.8\n#define WEIGHT_REWARD 0.1\n#define INPUT_VALUE 0.7\n#define WEIGHT_SUM_MAX 400.0\n/////////////////////Layer start///////////////////////////////////////\nclass layer{\n  public:\n    layer();\n    double runge_alpha;\n    double neuron[NEURON_NUMBER];\n    double neuron_output[NEURON_NUMBER];\n    double Excite[NEURON_NUMBER];\n    double Excite_external[NEURON_NUMBER];\n    double Excite_internal[NEURON_NUMBER];\n    double Inhibit[NEURON_NUMBER];\n    double Inhibit_external[NEURON_NUMBER];\n    double Inhibit_internal[NEURON_NUMBER];\n    double self_weight[NEURON_NUMBER][NEURON_NUMBER];\n    double k1[NEURON_NUMBER],k2[NEURON_NUMBER],k3[NEURON_NUMBER],k4[NEURON_NUMBER];\n    double get_neuron_output(int i){return neuron_output[i];};\n    void runge();\n    void update();\n    void self_feedback();\n    void initialize();\n    void sum();\n    void reset();\n    double InnerWeight( int neuron_i, int neuron_j);\n    double Gauss(double vd_stdev, double vd_meanValue);\n    double Runge( double X, double E, double I, double gauss);\n};\nvoid layer::reset(){\n  initialize();\n  int i_reset;\n  for(i_reset=0;i_reset< NEURON_NUMBER; i_reset++){\n    neuron[i_reset]=0.0;\n    neuron_output[i_reset]=0.0;\n  }\n}\nvoid layer::update(){\n  self_feedback();\n  sum();\n  runge();\n  initialize();\n}\nvoid layer::initialize(){\n  int i_initialize;\n  for( i_initialize = 0; i_initialize < NEURON_NUMBER; i_initialize++){\n    Excite[i_initialize] = 0.0;\n    Excite_external[i_initialize] = 0.0;\n    Excite_internal[i_initialize] = 0.0;\n    Inhibit[i_initialize] = 0.0;\n    Inhibit_external[i_initialize] = 0.0;\n    Inhibit_internal[i_initialize] = 0.0;\n  }\n}\nvoid layer::sum(){\n  int i_sum;\n  for( i_sum = 0; i_sum < NEURON_NUMBER; i_sum++){\n    Excite[i_sum] = Excite_internal[i_sum] + Excite_external[i_sum];\n    Inhibit[i_sum] = Inhibit_internal[i_sum] + Inhibit_external[i_sum];\n    if( Excite[i_sum] < 0.0 ){ Excite[i_sum]=0.0;}\n    if( Inhibit[i_sum] < 0.0 ){ Inhibit[i_sum]=0.0;}\n  }\n}\nvoid layer::self_feedback(){\n  int i_self_feedback;\n  int j_self_feedback;\n  for( i_self_feedback = 0; i_self_feedback <NEURON_NUMBER; i_self_feedback++){\n    for ( j_self_feedback = 0; j_self_feedback < NEURON_NUMBER; j_self_feedback++){\n      if( self_weight[j_self_feedback][i_self_feedback] >= 0.0 ){ Excite_internal[i_self_feedback] += self_weight[j_self_feedback][i_self_feedback] * pow(neuron_output[j_self_feedback],0.6);}\n      else{ Inhibit_internal[i_self_feedback] += -self_weight[j_self_feedback][i_self_feedback] * pow( neuron_output[j_self_feedback], 0.6);}\n    }\n  }\n}\nlayer::layer(){\n  int i_layer,j_layer;\n  runge_alpha = 2.7;\n  for( i_layer=0; i_layer<NEURON_NUMBER; i_layer++){\n    for( j_layer=0; j_layer<NEURON_NUMBER; j_layer++){\n      self_weight[i_layer][j_layer] = InnerWeight(i_layer,j_layer);\n    }\n  }\n}\nvoid layer::runge(){\n  int j_runge;\n  double gauss;\n  for(j_runge = 0 ; j_runge < NEURON_NUMBER ; j_runge++){\n    gauss = Gauss(0.2,0.0);\n    k1[j_runge] = dt * Runge( neuron[j_runge], Excite[j_runge] , Inhibit[j_runge], gauss);\n    k2[j_runge] = dt * Runge( neuron[j_runge] + (k1[j_runge])/2, Excite[j_runge], Inhibit[j_runge], gauss);\n    k3[j_runge] = dt * Runge( neuron[j_runge] + (k2[j_runge])/2, Excite[j_runge], Inhibit[j_runge], gauss);\n    k4[j_runge] = dt * Runge( neuron[j_runge] + k3[j_runge] , Excite[j_runge], Inhibit[j_runge], gauss);\n    neuron[j_runge] = neuron[j_runge] + ( k1[j_runge] + 2.0*k2[j_runge] + 2.0*k3[j_runge] + k4[j_runge] )/ 6.0;\n    if( neuron[j_runge] > 2.0 ){ neuron[j_runge] = 2.0;}\n    neuron_output[j_runge] = neuron[j_runge] - 0.135;\n    if( neuron[j_runge] < 0.0 ){ neuron[j_runge] = 0.0;}\n    if( neuron_output[j_runge] < 0.0 ){neuron_output[j_runge] = 0.0;}\n  }\n}\n\ndouble layer::InnerWeight( int neuron_i, int neuron_j){\n  double distance = 0.0;\n  double s = 2.50663;// sqrt( 2*PI )=2.50663\n  double weight = 0.0;\n  distance = (double)( neuron_i - neuron_j);\n  if (distance < -45){\n    distance = 90 + distance;\n  }\n  if (distance > 45){\n    distance = 90 - distance;\n  }\n  weight = 1.75*((1.0 / (s*exp( 0.005*distance*distance) )) - (0.4 / (s*exp( 0.00125*distance*distance )))) - 0.25;\n  return weight;\n}\ndouble layer::Runge( double X, double E, double I, double gauss){\n  double a;\n  a = -( runge_alpha * X) + (2.0 - X )*0.6*E - (X*I) + gauss;\n  return a;\n}\n/////////////////////Layer end////////////////////////////////////////\n// 【共通】ガウシアンノイズ生成\ndouble layer::Gauss( double vd_stdev,                           //  引数01: 標準偏差                              //\n    double vd_meanValue )                      //  引数02: 平均値                                //\n{                                                               //                                                //\n  double rtnNum = 0.0;                                        //  リターン用                                    //\n  static int sw = 0;                                          //  リターンの切替用                              //\n  //                                                //\n  double randNum_1;                                           //  乱数その１                                    //\n  double randNum_2;                                           //  乱数その２                                    //\n  double whiteGaussianNoise_1;                                //  ホワイトガウスノイズその１                    //\n  static double whiteGaussianNoise_2;                         //  ホワイトガウスノイズその２                    //\n  //                                                //\n  if( sw == 0 )                                               //  スイッチが0か                                 //\n  {                                                           //  スイッチが0なら                               //\n    sw = 1;                                                 //  スイッチ切替え                                //\n    randNum_1 = ((double)rand()) / RAND_MAX;                //  (0,9]の乱数取得                               //\n    randNum_2 = ((double)rand()) / RAND_MAX;                //  (0,9]の乱数取得                               //\n    //                                                //\n    whiteGaussianNoise_1 = vd_stdev * sqrt( -2.0 * log( randNum_1 ) ) *    //  正規乱数１                     //\n      cos( 2.0 * PI * randNum_2 ) + vd_meanValue; //                                 //\n    whiteGaussianNoise_2 = vd_stdev * sqrt( -2.0 * log( randNum_1 ) ) *    //  正規乱数２                     //\n      sin( 2.0 * PI * randNum_2 ) + vd_meanValue; //                                 //\n    //                                                //\n    rtnNum = whiteGaussianNoise_1;                          //  リターンに正規乱数１を設定                    //\n  }                                                           //                                                //\n  else                                                        //  スイッチが0以外の場合                         //\n  {                                                           //                                                //\n    sw = 0;                                                 //  スイッチ切替え                                //\n    //                                                //\n    rtnNum = whiteGaussianNoise_2;                          //  リターンに正規乱数２を設定                    //\n  }                                                           //                                                //\n  //                                                //\n  return rtnNum;                                           //  生成した正規乱数を返して終了\n}\n\n\n/////////////////////Direct Inferred start //////////////////////////\nclass DirectOrInferred{\n  public:\n    double Direct_out;\n    double Inferred_out;\n    void direct_on();\n    void inferred_on();\n    void direct_off();\n    void inferred_off();\n    double get_direct(){return Direct_out;};\n    double get_inferred(){return Inferred_out;};\n};\n\nvoid DirectOrInferred::direct_on()\n{\n  Direct_out = D_I_OUTPUT_VALUE;\n}\n\nvoid DirectOrInferred::direct_off()\n{\n  Direct_out = 0.0;\n}\n\nvoid DirectOrInferred::inferred_on()\n{\n  Inferred_out = D_I_OUTPUT_VALUE;\n}\n\nvoid DirectOrInferred::inferred_off()\n{\n  Inferred_out = 0.0;\n}\n\n\nbool reward_schedule(int choice_di_or_in, int reward_count_direct, int reward_count_inferred){\n  double random_number;\n  int count_subtraction;\n  if ( choice_di_or_in == 0){\n    count_subtraction = reward_count_inferred - reward_count_direct;\n  }else{\n    count_subtraction = reward_count_direct - reward_count_inferred;\n  }\n\n  random_number = (double)rand()/RAND_MAX;\n  if( count_subtraction > 1){\n    return true;\n  }else if(count_subtraction < -1 ){\n    return false;\n  }\n  if(count_subtraction == 1 && random_number > 0.3333333333333){\n    return true;\n  }\n  if(count_subtraction == 0 && random_number > 0.5){\n    return true;\n  }\n  if(count_subtraction == -1 && random_number > 0.666666666666){\n    return true;\n  }\n  return false;\n}\n\n\n/////////////////////Binding weight90-90 start/////////////////////////////\n\nclass bind_weight90{\n  public:\n    int i,pre,post;\n    double vd_stdev,vd_meanValue,weight_max,weight_sum_max;\n    bind_weight90();\n    double weight[NEURON_NUMBER][NEURON_NUMBER];\n    double get_weight(int pre,int post){return weight[pre][post];}\n    void reward(int pre_neu, int post_neu, double pre_active, double post_active);\n    void noreward(int pre_neu, int post_neu, double pre_active, double post_active);\n    double get_weight_sum();\n    void static_weight(double rate);\n    void static_reverse_weight(double rate_re);\n    void static_up();\n    void static_down();\n    void weight_normalize();\n    void weight_pmd(double rate_pmd);\n    void weight_record_PFC_In(int task_num);\n    void weight_record_PFC_Di(int task_num);\n    void weight_read_PFC_In();\n    void weight_read_PFC_Di();\n    double get_weight_sum_left();\n    double get_weight_sum_right();\n};\ndouble bind_weight90::get_weight_sum_left(){\n  double weight_sum = 0.0;\n  int i_straight,j_straight;\n  for(i_straight=0; i_straight<NEURON_NUMBER; i_straight++){\n    for(j_straight=0; j_straight<NEURON_NUMBER; j_straight++){\n      if(j_straight > 15 && j_straight < 30){\n        weight_sum += weight[i_straight][j_straight];\n      }\n    }\n  }\n  return weight_sum;\n}\ndouble bind_weight90::get_weight_sum_right(){\n  double weight_sum = 0.0;\n  int i_straight,j_straight;\n  for(i_straight=0; i_straight<NEURON_NUMBER; i_straight++){\n    for(j_straight=0; j_straight<NEURON_NUMBER; j_straight++){\n      if(j_straight > 60 && j_straight < 75){\n        weight_sum += weight[i_straight][j_straight];\n      }\n    }\n  }\n  return weight_sum;\n}\nvoid bind_weight90::weight_read_PFC_Di(){\n  ifstream read_data(\"weight_PFC_Di.data\");\n  string str;\n  int  i_weight_read,j_weight_read,i_file_read;\n  double  file_data[10000];\n  i_file_read = 0;\n  while((read_data >> file_data[i_file_read])!=0){\n    i_file_read++;\n  }\n  i_file_read = 0;\n  for(i_weight_read = 0; i_weight_read < NEURON_NUMBER; i_weight_read++){\n    for(j_weight_read = 0; j_weight_read < NEURON_NUMBER; j_weight_read++){\n      weight[i_weight_read][j_weight_read] = file_data[i_file_read];\n      i_file_read++;\n    }\n  }\n}\nvoid bind_weight90::weight_read_PFC_In(){\n  fstream read_data(\"weight_PFC_In.data\");\n  string str;\n  int  i_weight_read,j_weight_read,i_file_read;\n  double  file_data[10000];\n  i_file_read = 0;\n  while((read_data >> file_data[i_file_read])!=0){\n    i_file_read++;\n  }\n  i_file_read = 0;\n  for(i_weight_read = 0; i_weight_read < NEURON_NUMBER; i_weight_read++){\n    for(j_weight_read = 0; j_weight_read < NEURON_NUMBER; j_weight_read++){\n      weight[i_weight_read][j_weight_read] = file_data[i_file_read];\n      i_file_read++;\n    }\n  }\n}\nvoid bind_weight90::weight_record_PFC_In(int task_num){\n  char file_name[100];\n  sprintf(file_name, \"%d_%s\", task_num, \"weight_PFC_In.data\");\n  int i_weight_record,j_weight_record;\n  ofstream weight_out(file_name);\n  for(i_weight_record = 0; i_weight_record < NEURON_NUMBER; i_weight_record++){\n    for(j_weight_record = 0; j_weight_record < NEURON_NUMBER; j_weight_record++){\n      weight_out << weight[i_weight_record][j_weight_record] << endl;\n    }\n  }\n}\nvoid bind_weight90::weight_record_PFC_Di(int task_num){\n  char file_name[100];\n  sprintf(file_name, \"%d_%s\", task_num, \"weight_PFC_Di.data\");\n  int i_weight_record,j_weight_record;\n  ofstream weight_out(file_name);\n  for(i_weight_record = 0; i_weight_record < NEURON_NUMBER; i_weight_record++){\n    for(j_weight_record = 0; j_weight_record < NEURON_NUMBER; j_weight_record++){\n      weight_out << weight[i_weight_record][j_weight_record] << endl;\n    }\n  }\n}\n\n\nvoid bind_weight90::static_reverse_weight(double rate_re){\n  int i_bind,j_bind;\n  for(i_bind = 0; i_bind<NEURON_NUMBER;i_bind++){\n    for(j_bind = 0; j_bind<NEURON_NUMBER; j_bind++){\n      if(i_bind - j_bind == 45 || i_bind - j_bind == -45){\n        weight[i_bind][j_bind] = 0.8*rate_re;\n      }else if(i_bind - j_bind == 44 || i_bind - j_bind == -44 || i_bind - j_bind == 46 || i_bind - j_bind == -46){\n        weight[i_bind][j_bind] = 0.5*rate_re;\n      }else if(i_bind - j_bind == 43 || i_bind - j_bind == -43 || i_bind - j_bind == 47 || i_bind - j_bind == -47){\n        weight[i_bind][j_bind] = 0.2*rate_re;\n      }else{\n        weight[i_bind][j_bind] = 0.0;\n      }\n    }\n  }\n}\nvoid bind_weight90::weight_normalize(){\n  double sum,normalize_rate;\n  int i_normal,j_normal;\n  sum = get_weight_sum();\n  normalize_rate = weight_sum_max / sum;\n  for (i_normal=0; i_normal<NEURON_NUMBER; i_normal++){\n    for (j_normal=0; j_normal<NEURON_NUMBER; j_normal++){\n      weight[i_normal][j_normal] *= normalize_rate;\n    }\n  }\n}\ndouble bind_weight90::get_weight_sum(){\n  int i_sum,j_sum;\n  double sum=0.0;\n  for (i_sum=0;i_sum<NEURON_NUMBER;i_sum++){\n    for (j_sum=0;j_sum<NEURON_NUMBER;j_sum++){\n      sum += weight[i_sum][j_sum];\n    }\n  }\n  return sum;\n}\nvoid bind_weight90::reward(int pre_neu, int post_neu, double pre_active, double post_active){\n  weight[pre_neu][post_neu] += post_active*(weight[pre_neu][post_neu])*0.0001;\n  //if( weight[pre_neu][post_neu]>5.0){\n  //  weight[pre_neu][post_neu]=5.0;\n  //}\n}\n\nvoid bind_weight90::noreward(int pre_neu, int post_neu, double pre_active, double post_active){\n  weight[pre_neu][post_neu] -= post_active*(weight[pre_neu][post_neu])*0.0015;\n  if( weight[pre_neu][post_neu]<0.0){\n    weight[pre_neu][post_neu]=0.0;\n  }\n}\nvoid bind_weight90::static_weight(double rate){\n  int i_bind,j_bind;\n  for(i_bind = 0; i_bind<NEURON_NUMBER;i_bind++){\n    for(j_bind = 0; j_bind<NEURON_NUMBER; j_bind++){\n      if(i_bind==j_bind){\n        weight[i_bind][j_bind] = 0.8*rate;\n      }else if((i_bind - j_bind)*(i_bind - j_bind) == 1){\n        weight[i_bind][j_bind] = 0.5*rate;\n      }else if((i_bind - j_bind)*(i_bind - j_bind) == 4){\n        weight[i_bind][j_bind] = 0.2*rate;\n      }else{\n        weight[i_bind][j_bind] = 0.0;\n      }\n    }\n  }\n}\n\nvoid bind_weight90::weight_pmd(double rate_pmd){\n  int i_pmd,j_pmd;\n  for(i_pmd = 0; i_pmd<NEURON_NUMBER;i_pmd++){\n    for(j_pmd = 0; j_pmd<NEURON_NUMBER; j_pmd++){\n      if(i_pmd - j_pmd > 45){\n        weight[i_pmd][j_pmd] = (0.4 - 0.2*(90 - i_pmd + j_pmd))*rate_pmd;\n      }else if(i_pmd - j_pmd < -45){\n        weight[i_pmd][j_pmd] = (0.4 - 0.2*(90 + i_pmd - j_pmd))*rate_pmd;\n      }else if(i_pmd - j_pmd >= 0){\n        weight[i_pmd][i_pmd] = (0.4 - 0.2*(i_pmd - j_pmd))*rate_pmd;\n      }else{\n        weight[i_pmd][j_pmd] = (0.4 - 0.2*(- i_pmd + j_pmd))*rate_pmd;\n      }\n    }\n  }\n}\nvoid bind_weight90::static_up(){\n  int i_bind,j_bind;\n  for(i_bind = 0; i_bind<NEURON_NUMBER;i_bind++){\n    for(j_bind = 0; j_bind<NEURON_NUMBER; j_bind++){\n      if(i_bind==j_bind){\n        weight[i_bind][j_bind] += 0.08;\n      }else if((i_bind - j_bind)*(i_bind - j_bind) == 1){\n        weight[i_bind][j_bind] += 0.05;\n      }else if((i_bind - j_bind)*(i_bind - j_bind) == 4){\n        weight[i_bind][j_bind] += 0.02;\n      }else{\n        weight[i_bind][j_bind] = 0.0;\n      }\n    }\n  }\n}\nvoid bind_weight90::static_down(){\n  int i_bind,j_bind;\n  for(i_bind = 0; i_bind<NEURON_NUMBER;i_bind++){\n    for(j_bind = 0; j_bind<NEURON_NUMBER; j_bind++){\n      if(i_bind==j_bind){\n        weight[i_bind][j_bind] -= 0.08;\n      }else if((i_bind - j_bind)*(i_bind - j_bind) == 1){\n        weight[i_bind][j_bind] -= 0.05;\n      }else if((i_bind - j_bind)*(i_bind - j_bind) == 4){\n        weight[i_bind][j_bind] -= 0.02;\n      }else{\n        weight[i_bind][j_bind] = 0.0;\n      }\n    }\n  }\n}\nbind_weight90::bind_weight90(){\n  weight_max = WEIGHT_MAX;\n  weight_sum_max = WEIGHT_SUM_MAX;\n  int i_bind,j_bind;\n  for(i_bind = 0; i_bind<NEURON_NUMBER;i_bind++){\n    for(j_bind = 0; j_bind<NEURON_NUMBER; j_bind++){\n      weight[i_bind][j_bind] = ((double)rand()/RAND_MAX)*0.25;\n      if(weight[i_bind][j_bind]<0){\n        weight[i_bind][j_bind] = 0.0;\n      }\n    }\n  }\n}\n\n/////////////////////Binding weight90-90 end//////////////////////////////\n\nbool collect_or_mistake(int RorL, int DorI, double left_choice, double right_choice){\n  if(RorL == 0 && DorI == 0 && left_choice < right_choice){\n    return true;\n  }\n  if(RorL == 1 && DorI == 0 && left_choice > right_choice){\n    return true;\n  }\n  if(RorL == 1 && DorI == 1 && left_choice < right_choice){\n    return true;\n  }\n  if(RorL == 0 && DorI == 1 && left_choice > right_choice){\n    return true;\n  }\n  return false;\n}\ndouble correct_rate(int bunshi, int bunbo){\n  double bunshi_double, bunbo_double;\n  bunshi_double = bunshi;\n  bunbo_double = bunbo;\n  return bunshi_double / bunbo_double;\n}\n\n\n\n////////////////////main start/////////////////////////////////////////\n\nint main(void)\n{\n  int i,j,i_bind,j_bind,i_task,i_reward,j_reward,reward_check,go_sign;\n  double left_choice,right_choice,input_rate_ppc,decrement_rate;\n  double PFC1_active[90],PFC2_active[90],BG1_active[90];\n  for(int kuriu=0;kuriu < NEURON_NUMBER; kuriu++){\n    PFC1_active[kuriu] = 0.0;\n    PFC2_active[kuriu] = 0.0;\n    BG1_active[kuriu] = 0.0;\n  }\n  DirectOrInferred DioIn;\n  layer PPC;\n  layer PFC_1;\n  PFC_1.runge_alpha = 1.67;\n  layer PFC_2;\n  PFC_2.runge_alpha = 1.67;\n  layer BG_1;\n  BG_1.runge_alpha = 3.2;\n  layer PMd_1;\n  layer M1;\n  srand((unsigned)time(NULL));\n  bind_weight90 PFC_1toBG_1;\n  bind_weight90 PFC_2toBG_1;\n  bind_weight90 PFC_1toPMd_1;\n  bind_weight90 PFC_2toPMd_1;\n  bind_weight90 BG_1toPMd_1;\n  bind_weight90 PPCtoPMd_1;\n  bind_weight90 PMd_1toPPC;\n  bind_weight90 PMd_1toM1;\n  bind_weight90 M1toPMd_1;\n  PPCtoPMd_1.static_weight(1.35);\n  PFC_1toPMd_1.static_weight(1.0);\n  PFC_2toPMd_1.static_weight(1.5);\n  PFC_1toBG_1.static_weight(1.0);\n  PFC_2toBG_1.static_weight(1.35);\n  M1toPMd_2.static_weight(0.1);\n  BG_1toPMd_1.static_weight(1.5);\n  PMd_1toPPC.static_weight(1.2);\n  PMd_1toPMd_2.static_weight(1.2);\n  PMd_2toPMd_1.static_weight(1.2);\n  PMd_2toM1.static_weight(1.2);\n  M1toPMd_2.static_weight(1.2);\n  //PFC_1toBG_1.weight_read_PFC_Di();\n  //PFC_2toBG_1.weight_read_PFC_In();\n  ofstream fout(\"a.data\");\n  ofstream fout2(\"left_right.data\");\n  ofstream fout_weight_Di(\"weight_Di.data\");\n  ofstream fout_weight_In(\"weight_In.data\");\n  int correct_bunbo = 0;\n  int correct_bunshi = 0;\n  int i_correct = 0;\n  int RorL = 0;\n  int DorI = 0;\n  int reward_count_direct = 0;\n  int reward_count_inferred = 0;\n  int choice_di_or_in = 0;\n  double weight_max = WEIGHT_MAX;\n  double weight_reward = WEIGHT_REWARD;\n  double input_value = INPUT_VALUE;\n\n  correct_bunbo = 0;\n  correct_bunshi = 0;\n  i_correct = 0;\n  for(i_task=0;i_task<TASK_STEP;i_task++){\n\n    switch (i_task % 22){\n      case 0:\n        RorL = 1;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 1:\n        RorL = 1;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 2:\n        RorL = 1;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 3:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 4:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 5:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 6:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 7:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 8:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n      case 9:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 10:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 11:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 12:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 13:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=0;\n        break;\n      case 14:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=1;\n        break;\n      case 15:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=1;\n        break;\n      case 16:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=1;\n        break;\n      case 17:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=1;\n        break;\n      case 18:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign=1;\n        break;\n      case 19:\n        RorL = 2;\n        DorI = 2;\n        reward_check=0;\n        go_sign = 1;\n        break;\n      case 20:\n        RorL = 2;\n        DorI = 2;\n        reward_check=1;\n        go_sign = 1;\n        break;\n      default:\n        PPC.reset();\n        PFC_1.reset();\n        PFC_2.reset();\n        BG_1.reset();\n        PMd_1.reset();\n        M1.reset();\n        reward_check=0;\n        go_sign=0;\n        RorL=2;\n        DorI =2;\n        for(int kuriu=0;kuriu < NEURON_NUMBER; kuriu++){\n          PFC1_active[kuriu] = 0.0;\n          PFC2_active[kuriu] = 0.0;\n          BG1_active[kuriu] = 0.0;\n        }\n        break;\n    }\n    for(i=0;i<TIME;i++){\n      switch (DorI) {\n        case 0:\n          DioIn.inferred_off();\n          DioIn.direct_on();\n          break;\n        case 1:\n          DioIn.inferred_on();\n          DioIn.direct_off();\n          break;\n        default:\n          DioIn.inferred_off();\n          DioIn.direct_off();\n          break;\n      }\n      if( i_task > TASK_STEP - 22){\n        for(j=0;j<(NEURON_NUMBER/8) ; j++){\n          fout << DioIn.get_direct();\n          fout << \" \";\n        }\n        for(j=0;j<(NEURON_NUMBER/8) ; j++){\n          fout << DioIn.get_inferred();\n          fout << \" \";\n        }\n        for (j = 0; j<5; j++){\n          fout << -0.2;\n          fout << \" \";\n        }\n      }\n      //decrement_rate = (10000.0-i_task)/(10000.0);\n      //input_rate_ppc = 2.5;\n      input_rate_ppc = 2.5;\n      decrement_rate = 1.0;\n      if(RorL == 0){\n        //PPC.Excite_external[xx] += input_value*((360.0 - i_task)/360.0);\n        PPC.Excite_external[62] += input_value*input_rate_ppc*decrement_rate;\n        PPC.Excite_external[63] += input_value*input_rate_ppc*decrement_rate;\n        PPC.Excite_external[64] += input_value*input_rate_ppc*decrement_rate;\n        PPC.Excite_external[65] += input_value*input_rate_ppc*decrement_rate;\n        PPC.Excite_external[66] += input_value*input_rate_ppc*decrement_rate;\n        PPC.Excite_external[67] += input_value*input_rate_ppc*decrement_rate;\n        PPC.Excite_external[68] += input_value*input_rate_ppc*decrement_rate;\n        PFC_1.Excite_external[62] += input_value*decrement_rate;\n        PFC_1.Excite_external[63] += input_value*decrement_rate;\n        PFC_1.Excite_external[64] += input_value*decrement_rate;\n        PFC_1.Excite_external[65] += input_value*decrement_rate;\n        PFC_1.Excite_external[66] += input_value*decrement_rate;\n        PFC_1.Excite_external[67] += input_value*decrement_rate;\n        PFC_1.Excite_external[68] += input_value*decrement_rate;\n        PFC_2.Excite_external[19] += input_value*decrement_rate;\n        PFC_2.Excite_external[20] += input_value*decrement_rate;\n        PFC_2.Excite_external[21] += input_value*decrement_rate;\n        PFC_2.Excite_external[22] += input_value*decrement_rate;\n        PFC_2.Excite_external[23] += input_value*decrement_rate;\n        PFC_2.Excite_external[24] += input_value*decrement_rate;\n        PFC_2.Excite_external[25] += input_value*decrement_rate;\n        if( i_task > TASK_STEP - 22){\n          for(j=0;j<(NEURON_NUMBER/8); j++){\n            fout << 0.0;\n            fout << \" \";\n          }\n          for(j=0;j<(NEURON_NUMBER/8); j++){\n            fout << 0.5;\n            fout << \" \";\n          }\n        }\n      }\n      if(RorL == 1){\n        PPC.Excite_external[19] += input_value*input_rate_ppc;\n        PPC.Excite_external[20] += input_value*input_rate_ppc;\n        PPC.Excite_external[21] += input_value*input_rate_ppc;\n        PPC.Excite_external[22] += input_value*input_rate_ppc;\n        PPC.Excite_external[23] += input_value*input_rate_ppc;\n        PPC.Excite_external[24] += input_value*input_rate_ppc;\n        PPC.Excite_external[25] += input_value*input_rate_ppc;\n        PFC_1.Excite_external[19] += input_value;\n        PFC_1.Excite_external[20] += input_value;\n        PFC_1.Excite_external[21] += input_value;\n        PFC_1.Excite_external[22] += input_value;\n        PFC_1.Excite_external[23] += input_value;\n        PFC_1.Excite_external[24] += input_value;\n        PFC_1.Excite_external[25] += input_value;\n        PFC_2.Excite_external[62] += input_value;\n        PFC_2.Excite_external[63] += input_value;\n        PFC_2.Excite_external[64] += input_value;\n        PFC_2.Excite_external[65] += input_value;\n        PFC_2.Excite_external[66] += input_value;\n        PFC_2.Excite_external[67] += input_value;\n        PFC_2.Excite_external[68] += input_value;\n        if( i_task > TASK_STEP - 22){\n          for(j=0;j<(NEURON_NUMBER/8); j++){\n            fout << 0.5;\n            fout << \" \";\n          }\n          for(j=0;j<(NEURON_NUMBER/8); j++){\n            fout << 0.0;\n            fout << \" \";\n          }\n        }\n      }\n      if(RorL == 2){\n        if( i_task > TASK_STEP - 22){\n          for(j=0;j<(NEURON_NUMBER/8); j++){\n            fout << 0.0;\n            fout << \" \";\n          }\n          for(j=0;j<(NEURON_NUMBER/8); j++){\n            fout << 0.0;\n            fout << \" \";\n          }\n        }\n      }\n      if(go_sign==1){\n        for(j=0;j<(NEURON_NUMBER);j++){\n          PFC_1.Excite_external[j] += DioIn.get_direct();\n          PFC_2.Excite_external[j] += DioIn.get_inferred();\n        }\n      }\n      for(i_bind = 0; i_bind < NEURON_NUMBER; i_bind++){\n        for(j_bind = 0; j_bind < NEURON_NUMBER; j_bind++){\n          PPC.Excite_external[j_bind] += PMd_1toPPC.get_weight(i_bind,j_bind)*PMd_1.neuron_output[i_bind];\n          BG_1.Excite_external[j_bind] += PFC_1toBG_1.get_weight(i_bind,j_bind)*PFC_1.neuron_output[i_bind] + PFC_2toBG_1.get_weight(i_bind,j_bind)*PFC_2.neuron_output[i_bind];\n          PMd_1.Excite_external[j_bind] += BG_1toPMd_1.get_weight(i_bind,j_bind)*BG_1.neuron_output[i_bind] + PPCtoPMd_1.get_weight(i_bind,j_bind)*PPC.neuron_output[i_bind] + M1toPMd_1.get_weight(i_bind,j_bind)*M1.neuron_output[i_bind] + PFC_1toPMd_1.get_weight(i_bind,j_bind)*PFC_1.neuron_output[i_bind] + PFC_2toPMd_1.get_weight(i_bind,j_bind)*PFC_2.neuron_output[i_bind];\n          if(j_bind<45){\n            PMd_1.Inhibit_external[j_bind+45] += BG_1toPMd_1.get_weight(i_bind,j_bind)*BG_1.neuron_output[i_bind];\n          }else{\n            PMd_1.Inhibit_external[j_bind-45] += BG_1toPMd_1.get_weight(i_bind,j_bind)*BG_1.neuron_output[i_bind];\n          }\n          if(go_sign==1){\n            M1.Excite_external[j_bind] += PMd_1toM1.get_weight(i_bind,j_bind)*PMd_1.neuron_output[i_bind]*1.0;\n          }\n        }\n      }\n      BG_1.update();\n      PFC_1.update();\n      PFC_2.update();\n      PMd_1.update();\n      M1.update();\n      PPC.update();\n      for (j = 0; j< NEURON_NUMBER; j++){\n        PFC1_active[j] += PFC_1.get_neuron_output(j);\n        PFC2_active[j] += PFC_2.get_neuron_output(j);\n        BG1_active[j] += BG_1.get_neuron_output(j);\n      }\n      if( i_task > TASK_STEP - 22){\n        for (j = 0; j<5; j++){\n          fout << -0.2;\n          fout << \" \";\n        }\n        for (j = 0; j< NEURON_NUMBER; j++){\n          fout << PPC.get_neuron_output(j);\n          fout << \" \";\n        }\n        for (j = 0; j<5; j++){\n          fout << -0.2;\n          fout << \" \";\n        }\n        for (j = 0; j< NEURON_NUMBER; j++){\n          fout << PMd_1.get_neuron_output(j);\n          fout << \" \";\n        }\n        for (j = 0; j<5; j++){\n          fout << -0.2;\n          fout << \" \";\n        }\n        for (j = 0; j< NEURON_NUMBER; j++){\n          fout << M1.get_neuron_output(j);\n          fout << \" \";\n        }\n        for (j = 0; j<5; j++){\n          fout << -0.2;\n          fout << \" \";\n        }\n        for (j = 0; j< NEURON_NUMBER; j++){\n          fout << PFC_1.get_neuron_output(j);\n          fout << \" \";\n\n        }\n        for (j = 0; j<5; j++){\n          fout << -0.2;\n          fout << \" \";\n        }\n        for (j = 0; j< NEURON_NUMBER; j++){\n          fout << PFC_2.get_neuron_output(j);\n          fout << \" \";\n        }\n        for (j = 0; j<5; j++){\n          fout << -0.2;\n          fout << \" \";\n        }\n        for (j = 0; j< NEURON_NUMBER; j++){\n          fout << BG_1.get_neuron_output(j);\n          fout << \" \";\n        }\n      }\n      right_choice=0.0;\n      left_choice=0.0;\n      for ( j=0; j<NEURON_NUMBER;j++){\n        if(j >= 15 && j <= 30 ){\n          left_choice += M1.get_neuron_output(j);\n        }else if(j >= 60 && j <= 75){\n          right_choice += M1.get_neuron_output(j);\n        }\n      }\n      /* M1が右を選んだか、左を選んだかプロット */\n      if( i_task > TASK_STEP - 22){\n        fout <<\"\\n\";\n      }\n    }\n    cout << i_task<< \"left\"<<left_choice<<\"right\"<<right_choice<< endl;\n\n    if(reward_check == 1){\n\n\n      if(right_choice < left_choice){\n        choice_di_or_in = 0;\n      }else{\n        choice_di_or_in = 1;\n      }\n\n\n      //reward_count_inferred=0;\n      //reward_count_direct=0;//バランス後の平等な報酬を再現するなら有効\n      //if(reward_schedule(choice_di_or_in, reward_count_direct, reward_count_inferred)){\n      //  if(choice_di_or_in == 0){\n      //    reward_count_direct++;\n      //    cout << \"direct_reward\" << endl;\n      //  }else{\n      //    reward_count_inferred++;\n      //    cout << \"inferred_reward\" << endl;\n      //  }\n\n      //i_correct++;\n      if(left_choice < right_choice){\n      //if(collect_or_mistake(RorL, DorI, left_choice, right_choice)){\n        correct_bunshi++;\n        correct_bunbo++;\n        cout << \"          correct\" << endl;\n        for(i_reward=0;i_reward<NEURON_NUMBER;i_reward++){\n          for(j_reward=0;j_reward<NEURON_NUMBER;j_reward++){\n            PFC_1toBG_1.reward(j_reward, i_reward, PFC1_active[j_reward] , BG1_active[i_reward]);\n            //cout << j_reward << \" \" << i_reward << \" \" << PFC1_active[j_reward] << \" \" << BG1_active[i_reward] << endl;\n            PFC_2toBG_1.reward(j_reward, i_reward, PFC2_active[j_reward] , BG1_active[i_reward]);\n          }\n          //cout << PFC1_active[i_reward] << PFC2_active[i_reward] << BG1_active[i_reward] << endl;\n        }\n      }else{\n        correct_bunbo++;\n        cout << \"          in correct\" << endl;\n        for(i_reward=0;i_reward<NEURON_NUMBER;i_reward++){\n          for(j_reward=0;j_reward<NEURON_NUMBER;j_reward++){\n            PFC_1toBG_1.noreward(j_reward, i_reward, PFC1_active[j_reward] , BG1_active[i_reward]);\n            PFC_2toBG_1.noreward(j_reward, i_reward, PFC2_active[j_reward] , BG1_active[i_reward]);\n          }\n        }\n      }\n      if(i_correct == 99){\n        fout2 << correct_rate(correct_bunshi, correct_bunbo) << \"\\n\";\n        i_correct = 0;\n        correct_bunshi = 0;\n        correct_bunbo = 0;\n      }\n      //PFC_1toBG_1.weight_normalize();\n      //PFC_2toBG_1.weight_normalize();\n      PFC_1toBG_1.weight_record_PFC_Di(i_task);\n      PFC_2toBG_1.weight_record_PFC_In(i_task);\n      fout_weight_Di << PFC_1toBG_1.get_weight_sum_left() << endl;\n      fout_weight_In << PFC_2toBG_1.get_weight_sum_right() << endl;\n      if (left_choice > right_choice){\n        fout2 << \"0\\n\";\n        cout << \"left\" << endl;\n      }else{\n        fout2 << \"1\\n\";\n        cout << \"right\" << endl;\n      }\n    }\n    }\n    fout.close();\n    fout2.close();\n    return 0;\n  }\n  /////////////////////main end/////////////////////////////////////\n","markers":{"markers":{"1":{"id":1,"range":[[124,51],[124,51]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":74,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"oldRange":[[170,0],[170,0]],"newRange":[[170,0],[171,0]],"oldText":"","newText":"class DirectOrInferred{\n","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{},"deserializer":"MarkerPatch"},{"oldRange":[[166,1],[166,1]],"newRange":[[166,1],[167,0]],"oldText":"","newText":"\n","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"reversed":true,"range":[[166,1],[167,0]]},"newParams":{"range":[[167,0],[167,0]]},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[167,0],[167,0]],"newRange":[[167,0],[167,0]],"oldText":"","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[166,1],[167,0]],"newRange":[[166,1],[166,1]],"oldText":"\n","newText":"","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"},{"oldRange":[[166,1],[166,1]],"newRange":[[166,1],[166,2]],"oldText":"","newText":"い","normalizeLineEndings":{"undo":"skip"},"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":false,"range":[[166,2],[166,2]]},"newParams":{"tailed":true,"range":[[166,1],[166,2]]},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"range":[[166,1],[166,2]]},"newParams":{"range":[[166,2],[166,2]]},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"},{"oldRange":[[166,1],[166,2]],"newRange":[[166,1],[166,1]],"oldText":"い","newText":"","normalizeLineEndings":{"undo":"skip"},"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"},{"oldRange":[[166,1],[166,1]],"newRange":[[166,1],[166,2]],"oldText":"","newText":"い","normalizeLineEndings":{"undo":"skip"},"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":false,"range":[[166,2],[166,2]]},"newParams":{"tailed":true,"range":[[166,1],[166,2]]},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"range":[[166,1],[166,2]]},"newParams":{"range":[[166,2],[166,2]]},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"},{"oldRange":[[166,1],[166,2]],"newRange":[[166,1],[166,1]],"oldText":"い","newText":"","normalizeLineEndings":{"undo":"skip"},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"deserializer":"History"},"filePath":"/Users/regonn/RESEARCH/model/BG-PFC-rewardmodel.cpp","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"257c981dc29631e0d2de8629a429e93cdb14a6b3","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":74,"softTabs":true,"displayBuffer":{"id":75,"softWrap":false,"editorWidthInChars":95,"scrollTop":19033,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/regonn/RESEARCH/model/BG-PFC-rewardmodel.cpp","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/regonn/RESEARCH/model/BG-PFC-rewardmodel.cpp","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/regonn/RESEARCH/model/BG-PFC-rewardmodel.cpp":1399458961128},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":330918},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/regonn/RESEARCH","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}